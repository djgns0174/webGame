<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Fortress Duels: Dynamic Warfare</title>
    <style>
      body {
        margin: 0;
        height: 100vh;
        display: flex;
        justify-content: center;
        align-items: center;
      }
      #fortress {
        border: 1px solid black;
      }
    </style>
  </head>
  <body>
    <canvas id="fortress" width="2000" height="900"></canvas>
    <script>
      const canvas = document.getElementById("fortress");
      const ctx = canvas.getContext("2d");
      const width = canvas.width;
      const height = canvas.height;
      var backgroundImage = new Image();
      backgroundImage.src = "./picture/main.jpg";

      let intervalId;

      backgroundImage.onload = function () {
        console.log("Image loaded");
        start(); // 게임 시작
      };

      const start = () => {
        intervalId = setInterval(draw, 10);
      };

      const tankWidth = 150;
      const tankHeight = 150;
      const tankDx = 3;
      const cannonAngleDIF = Math.PI / 60;
      const cannonLength = 100 * Math.sqrt(2);
      const initialHealth = 100;
      const defaultMissileRadius = 5;

      function Tank(type, skillKeys) {
        this.type = type;
        this.skillKeys = skillKeys;
        this.skillAvailable = [true, true, true];
      }

      // Player 1
      let player1Tank = new Tank("userLeft", ["1", "2", "3"]);
      let tank1X = 0;
      let tank1CenterX;
      let tank1CenterY;
      let cannon1Angle = Math.PI / 4;
      let tank1LeftPressed = false;
      let tank1RightPressed = false;
      let player1Health = initialHealth;
      let player1DamageMultiplier = 1;
      let player1MissileRadiusMultiplier = 1;
      let player1DoubleAttack = false;
      let player1IncreasedRange = false;

      // Player 2
      let player2Tank = new Tank("userRight", ["8", "9", "0"]);
      let tank2X = width - tankWidth;
      let tank2CenterX;
      let tank2CenterY;
      let cannon2Angle = (3 * Math.PI) / 4;
      let tank2LeftPressed = false;
      let tank2RightPressed = false;
      let player2Health = initialHealth;
      let player2DamageMultiplier = 1;
      let player2MissileRadiusMultiplier = 1;
      let player2DoubleAttack = false;
      let player2IncreasedRange = false;

      let missileRadius = defaultMissileRadius;
      let missileX;
      let missileY;
      let isCharging = false;
      let isFired = false;
      let gauge = Math.PI;
      const gaugeDIF = Math.PI / 60;
      const gaugeBarRadius = 30;
      let missilePower;
      let missileDx;
      let missileDy;
      const GRAVITY_ACCELERATION = 0.098;

      let currentPlayer = 1; // 1: Player 1, 2: Player 2
      let currentPlayerShots = 1; // 기본 1회 공격
      let shotsFired = 0;

      const draw = () => {
        ctx.clearRect(0, 0, width, height);
        ctx.drawImage(backgroundImage, 0, 0, width, height); // 매 프레임마다 배경 이미지 그리기

        // 플레이어 상태 표시
        drawPlayerStatus();

        tank1CenterX = tank1X + 0.5 * tankWidth;
        tank1CenterY = height - 0.5 * tankHeight;
        tank2CenterX = tank2X + 0.5 * tankWidth;
        tank2CenterY = height - 0.5 * tankHeight;

        if (tank1LeftPressed && tank1X > 0) {
          tank1X -= tankDx;
        }
        if (tank1RightPressed && tank1X + tankWidth < width) {
          tank1X += tankDx;
        }

        if (tank2LeftPressed && tank2X > 0) {
          tank2X -= tankDx;
        }
        if (tank2RightPressed && tank2X + tankWidth < width) {
          tank2X += tankDx;
        }

        if (isCharging && !isFired) {
          if (gauge < Math.PI * 2) {
            gauge += gaugeDIF;
          }
          drawGausing();
        }

        if (!isFired) {
          missileRadius =
            currentPlayer === 1
              ? defaultMissileRadius * player1MissileRadiusMultiplier
              : defaultMissileRadius * player2MissileRadiusMultiplier;

          if (currentPlayer === 1) {
            missileX = tank1CenterX + cannonLength * Math.cos(cannon1Angle);
            missileY = tank1CenterY - cannonLength * Math.sin(cannon1Angle);
          } else {
            missileX = tank2CenterX + cannonLength * Math.cos(cannon2Angle);
            missileY = tank2CenterY - cannonLength * Math.sin(cannon2Angle);
          }
        } else {
          missileDy -= GRAVITY_ACCELERATION;
          missileX = missileX + missileDx;
          missileY = missileY - missileDy;
        }
        checkMissile();
        drawTank(
          tank1X,
          tank1CenterX,
          tank1CenterY,
          cannon1Angle,
          player1Health
        );
        drawTank(
          tank2X,
          tank2CenterX,
          tank2CenterY,
          cannon2Angle,
          player2Health
        );
        drawMissile();
      };

      const checkMissile = () => {
        // canvas 왼쪽, 오른쪽, 아래 벽에 닿으면
        if (missileX <= 0 || missileX >= width || missileY >= height) {
          handleMissileEnd();
        }

        // Player 1 명중
        if (
          currentPlayer === 2 &&
          missileX >= tank1X &&
          missileX <=
            tank1X + (player2IncreasedRange ? 2 * tankWidth : tankWidth) &&
          missileY >=
            height - (player2IncreasedRange ? 2 * tankHeight : tankHeight)
        ) {
          player1Health -= 20 * player2DamageMultiplier;
          isFired = false;
          if (player1Health <= 0) {
            clearInterval(intervalId);
            alert("Player 2 wins!");
            location.reload();
          } else {
            handleMissileEnd();
          }
        }

        // Player 2 명중
        if (
          currentPlayer === 1 &&
          missileX >= tank2X &&
          missileX <=
            tank2X + (player1IncreasedRange ? 2 * tankWidth : tankWidth) &&
          missileY >=
            height - (player1IncreasedRange ? 2 * tankHeight : tankHeight)
        ) {
          player2Health -= 20 * player1DamageMultiplier;
          isFired = false;
          if (player2Health <= 0) {
            clearInterval(intervalId);
            alert("Player 1 wins!");
            location.reload();
          } else {
            handleMissileEnd();
          }
        }
      };

      const handleMissileEnd = () => {
        isFired = false;
        shotsFired++;
        if (shotsFired < currentPlayerShots) {
          // 현재 턴에서 두 번 공격을 가능하게 하는 로직
          gauge = Math.PI; // 파워 게이지 초기화
        } else {
          switchPlayer();
        }
      };

      const switchPlayer = () => {
        currentPlayer = currentPlayer === 1 ? 2 : 1;
        isFired = false;
        isCharging = false;
        gauge = Math.PI;
        resetKeys();
        resetMultipliers();
        shotsFired = 0;
        currentPlayerShots = 1;
      };

      const resetKeys = () => {
        tank1LeftPressed = false;
        tank1RightPressed = false;
        tank2LeftPressed = false;
        tank2RightPressed = false;
      };

      const resetMultipliers = () => {
        player1DamageMultiplier = 1;
        player2DamageMultiplier = 1;
        player1MissileRadiusMultiplier = 1;
        player2MissileRadiusMultiplier = 1;
        player1IncreasedRange = false;
        player2IncreasedRange = false;
      };

      const drawMissile = () => {
        ctx.beginPath();
        ctx.arc(missileX, missileY, missileRadius, 0, Math.PI * 2);
        ctx.fillStyle = "blue";
        ctx.fill();
        ctx.closePath();
      };

      const drawGausing = () => {
        let centerX = currentPlayer === 1 ? tank1CenterX : tank2CenterX;
        let centerY =
          currentPlayer === 1
            ? tank1CenterY - cannonLength
            : tank2CenterY - cannonLength;
        ctx.beginPath();
        ctx.arc(centerX, centerY, gaugeBarRadius, Math.PI, gauge, false);
        ctx.stroke();
      };

      const tank2BodyImg = new Image();
      tank2BodyImg.src = "./picture/tank2BodyImage.png";
      const cannon2Image = new Image();
      cannon2Image.src = "./picture/cannon2Image.png";
      const drawTank = (tankX, tankCenterX, tankCenterY, cannonAngle) => {
        ctx.drawImage(
          tank2BodyImg,
          tankX,
          height - tankHeight,
          tankWidth,
          tankHeight
        );

        // 포신 이미지 회전 및 그리기
        ctx.save();
        ctx.translate(tankCenterX, tankCenterY);
        ctx.rotate(-cannonAngle); // 캔버스의 y축이 아래쪽을 향하므로 -를 붙임
        ctx.drawImage(cannon2Image, 15, -25, 100, 70);
        ctx.restore();
      };

      const drawPlayerStatus = () => {
        ctx.font = "20px Arial";
        ctx.fillStyle = "black";
        ctx.fillText(`Player 1 HP: ${player1Health}`, 20, 30);
        ctx.fillText(`Player 2 HP: ${player2Health}`, width - 150, 30);

        drawPlayerItems(player1Tank, 20, 50);
        drawPlayerItems(player2Tank, width - 150, 50);
      };

      const drawPlayerItems = (tank, startX, startY) => {
        const items = tank.skillAvailable;
        items.forEach((item, index) => {
          ctx.fillStyle = item ? "rgba(0, 0, 0, 1)" : "rgba(0, 0, 0, 0.5)";
          ctx.fillRect(startX + index * 40, startY, 30, 30);
        });
      };

      const keydownHandler = (event) => {
        const key = event.key;
        if (currentPlayer === 1) {
          if (key === "a" || key === "A") {
            // A key
            tank1LeftPressed = true;
          } else if (key === "d" || key === "D") {
            // D key
            tank1RightPressed = true;
          } else if (key === "w" || (key === "W" && cannon1Angle <= Math.PI)) {
            // W key
            cannon1Angle += cannonAngleDIF;
          } else if (key === "s" || (key === "S" && cannon1Angle >= 0)) {
            // S key
            cannon1Angle -= cannonAngleDIF;
          } else if (key === " ") {
            // Space key
            if (!isFired) isCharging = true;
          } else if (key === player1Tank.skillKeys[0]) {
            // Skill 1 key
            if (player1Tank.skillAvailable[0]) {
              player1DamageMultiplier = 2;
              useItem(player1Tank, 0);
            }
          } else if (key === player1Tank.skillKeys[1]) {
            // Skill 2 key
            if (player1Tank.skillAvailable[1]) {
              player1DoubleAttack = true;
              currentPlayerShots = 2; // 현재 턴에서 두 번 공격 가능하게 설정
              useItem(player1Tank, 1);
            }
          } else if (key === player1Tank.skillKeys[2]) {
            // Skill 3 key
            if (player1Tank.skillAvailable[2]) {
              player1IncreasedRange = true;
              useItem(player1Tank, 2);
            }
          }
        } else if (currentPlayer === 2) {
          if (key === "ArrowLeft") {
            tank2LeftPressed = true;
          } else if (key === "ArrowRight") {
            tank2RightPressed = true;
          } else if (key === "ArrowUp" && cannon2Angle <= Math.PI) {
            cannon2Angle += cannonAngleDIF;
          } else if (key === "ArrowDown" && cannon2Angle >= 0) {
            cannon2Angle -= cannonAngleDIF;
          } else if (key === " ") {
            if (!isFired) isCharging = true;
          } else if (key === player2Tank.skillKeys[0]) {
            // Skill 1 key
            if (player2Tank.skillAvailable[0]) {
              player2MissileRadiusMultiplier = 2;
              useItem(player2Tank, 0);
            }
          } else if (key === player2Tank.skillKeys[1]) {
            // Skill 2 key
            if (player2Tank.skillAvailable[1]) {
              player2IncreasedRange = true;
              useItem(player2Tank, 1);
            }
          } else if (key === player2Tank.skillKeys[2]) {
            // Skill 3 key
            if (player2Tank.skillAvailable[2]) {
              useItem(player2Tank, 2);
            }
          }
        }
      };

      const keyupHandler = (event) => {
        const key = event.key;
        if (currentPlayer === 1) {
          if (key === "a" || key === "A") {
            tank1LeftPressed = false;
          } else if (key === "d" || key === "D") {
            tank1RightPressed = false;
          } else if (key === " " && isCharging) {
            isCharging = false;
            isFired = true;
            missilePower = gauge * 1.6;
            missileDx = missilePower * Math.cos(cannon1Angle);
            missileDy = missilePower * Math.sin(cannon1Angle);
            gauge = Math.PI; // 게이지 초기화
          }
        } else {
          if (key === "ArrowLeft") {
            tank2LeftPressed = false;
          } else if (key === "ArrowRight") {
            tank2RightPressed = false;
          } else if (key === " " && isCharging) {
            isCharging = false;
            isFired = true;
            missilePower = gauge * 1.6;
            missileDx = missilePower * Math.cos(cannon2Angle);
            missileDy = missilePower * Math.sin(cannon2Angle);
            gauge = Math.PI; // 게이지 초기화
          }
        }
      };

      const useItem = (tank, itemIndex) => {
        tank.skillAvailable[itemIndex] = false;
      };

      document.addEventListener("keydown", keydownHandler, false);
      document.addEventListener("keyup", keyupHandler, false);
    </script>
  </body>
</html>
