<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Fortress Duels: Dynamic Warfare</title>
    <style>
      body {
        margin: 0;
        height: 100vh;
        display: flex;
        justify-content: center;
        align-items: center;
      }
      #fortress {
        border: 1px solid black;
      }
    </style>
  </head>
  <body>
    <canvas id="fortress" width="2000" height="900"></canvas>
    <script>
      const canvas = document.getElementById("fortress");
      const ctx = canvas.getContext("2d");
      const width = canvas.width;
      const height = canvas.height;
      var backgroundImage = new Image();
      backgroundImage.src = "./picture/main.jpg";

      let intervalId;

      backgroundImage.onload = function () {
        console.log("Image loaded");
        start(); // 게임 시작
      };

      const start = () => {
        intervalId = setInterval(draw, 10);
      };

      const tankWidth = 150;
      const tankHeight = 150;
      const tankDx = 3;
      const cannonAngleDIF = Math.PI / 60;
      const cannonLength = 100 * Math.sqrt(2);
      const initialHealth = 100;
      const defaultMissileRadius = 5;

      function Tank(type, skills) {
        this.type = type;
        this.skills = skills;
        this.skillAvailable = {
          damage: true,
          chance: true,
          big: true,
          area: true,
        };
        this.damageMultiplier = 1;
        this.missileRadiusMultiplier = 1;
        this.doubleAttack = false;
        this.increasedRange = false;
        this.sizeMultiplier = 1;
      }

      // Player 1
      let player1Tank = new Tank("userLeft", ["damage", "chance", "big"]);
      let tank1X = 0;
      let tank1CenterX;
      let tank1CenterY;
      let cannon1Angle = Math.PI / 4;
      let tank1LeftPressed = false;
      let tank1RightPressed = false;
      let player1Health = initialHealth;

      // Player 2
      let player2Tank = new Tank("userRight", ["damage", "big", "area"]);
      let tank2X = width - tankWidth;
      let tank2CenterX;
      let tank2CenterY;
      let cannon2Angle = (3 * Math.PI) / 4;
      let tank2LeftPressed = false;
      let tank2RightPressed = false;
      let player2Health = initialHealth;

      let missileRadius = defaultMissileRadius;
      let missileX;
      let missileY;
      let isCharging = false;
      let isFired = false;
      let gauge = Math.PI;
      const gaugeDIF = Math.PI / 60;
      const gaugeBarRadius = 30;
      let missilePower;
      let missileDx;
      let missileDy;
      const GRAVITY_ACCELERATION = 0.098;

      let currentPlayer = 1; // 1: Player 1, 2: Player 2
      let currentPlayerShots = 1; // 기본 1회 공격
      let shotsFired = 0;

      const draw = () => {
        ctx.clearRect(0, 0, width, height);
        ctx.drawImage(backgroundImage, 0, 0, width, height); // 매 프레임마다 배경 이미지 그리기

        // 플레이어 상태 표시
        drawPlayerStatus();

        tank1CenterX = tank1X + 0.5 * tankWidth * player1Tank.sizeMultiplier;
        tank1CenterY = height - 0.5 * tankHeight * player1Tank.sizeMultiplier;
        tank2CenterX = tank2X + 0.5 * tankWidth * player2Tank.sizeMultiplier;
        tank2CenterY = height - 0.5 * tankHeight * player2Tank.sizeMultiplier;

        if (tank1LeftPressed && tank1X > 0) {
          tank1X -= tankDx;
        }
        if (
          tank1RightPressed &&
          tank1X + tankWidth * player1Tank.sizeMultiplier < width
        ) {
          tank1X += tankDx;
        }

        if (tank2LeftPressed && tank2X > 0) {
          tank2X -= tankDx;
        }
        if (
          tank2RightPressed &&
          tank2X + tankWidth * player2Tank.sizeMultiplier < width
        ) {
          tank2X += tankDx;
        }

        if (isCharging && !isFired) {
          if (gauge < Math.PI * 2) {
            gauge += gaugeDIF;
          }
          drawGausing();
        }

        if (!isFired) {
          missileRadius =
            currentPlayer === 1
              ? defaultMissileRadius * player1Tank.missileRadiusMultiplier
              : defaultMissileRadius * player2Tank.missileRadiusMultiplier;

          if (currentPlayer === 1) {
            missileX = tank1CenterX + cannonLength * Math.cos(cannon1Angle);
            missileY = tank1CenterY - cannonLength * Math.sin(cannon1Angle);
          } else {
            missileX = tank2CenterX + cannonLength * Math.cos(cannon2Angle);
            missileY = tank2CenterY - cannonLength * Math.sin(cannon2Angle);
          }
        } else {
          missileDy -= GRAVITY_ACCELERATION;
          missileX = missileX + missileDx;
          missileY = missileY - missileDy;
        }
        checkMissile();
        drawTank(
          tank1X,
          tank1CenterX,
          tank1CenterY,
          cannon1Angle,
          player1Health,
          player1Tank.sizeMultiplier
        );
        drawTank(
          tank2X,
          tank2CenterX,
          tank2CenterY,
          cannon2Angle,
          player2Health,
          player2Tank.sizeMultiplier
        );
        drawMissile();
      };

      const checkMissile = () => {
        // canvas 왼쪽, 오른쪽, 아래 벽에 닿으면
        if (missileX <= 0 || missileX >= width || missileY >= height) {
          handleMissileEnd();
        }

        // Player 1 명중
        if (
          currentPlayer === 2 &&
          missileX >= tank1X &&
          missileX <=
            tank1X +
              (player2Tank.increasedRange ? 2 * tankWidth : tankWidth) *
                player1Tank.sizeMultiplier &&
          missileY >=
            height -
              (player2Tank.increasedRange ? 2 * tankHeight : tankHeight) *
                player1Tank.sizeMultiplier
        ) {
          player1Health -= 20 * player2Tank.damageMultiplier;
          isFired = false;
          if (player1Health <= 0) {
            clearInterval(intervalId);
            alert("Player 2 wins!");
            location.reload();
          } else {
            handleMissileEnd();
          }
        }

        // Player 2 명중
        if (
          currentPlayer === 1 &&
          missileX >= tank2X &&
          missileX <=
            tank2X +
              (player1Tank.increasedRange ? 2 * tankWidth : tankWidth) *
                player2Tank.sizeMultiplier &&
          missileY >=
            height -
              (player1Tank.increasedRange ? 2 * tankHeight : tankHeight) *
                player2Tank.sizeMultiplier
        ) {
          player2Health -= 20 * player1Tank.damageMultiplier;
          isFired = false;
          if (player2Health <= 0) {
            clearInterval(intervalId);
            alert("Player 1 wins!");
            location.reload();
          } else {
            handleMissileEnd();
          }
        }
      };

      const handleMissileEnd = () => {
        isFired = false;
        shotsFired++;
        if (shotsFired < currentPlayerShots) {
          // 현재 턴에서 두 번 공격을 가능하게 하는 로직
          gauge = Math.PI; // 파워 게이지 초기화
        } else {
          switchPlayer();
        }
      };

      const switchPlayer = () => {
        currentPlayer = currentPlayer === 1 ? 2 : 1;
        isFired = false;
        isCharging = false;
        gauge = Math.PI;
        resetKeys();
        resetMultipliers();
        shotsFired = 0;
        currentPlayerShots = 1;
      };

      const resetKeys = () => {
        tank1LeftPressed = false;
        tank1RightPressed = false;
        tank2LeftPressed = false;
        tank2RightPressed = false;
      };

      const resetMultipliers = () => {
        player1Tank.damageMultiplier = 1;
        player2Tank.damageMultiplier = 1;
        player1Tank.missileRadiusMultiplier = 1;
        player2Tank.missileRadiusMultiplier = 1;
        player1Tank.increasedRange = false;
        player2Tank.increasedRange = false;
        player1Tank.doubleAttack = false;
        player2Tank.doubleAttack = false;
        player1Tank.sizeMultiplier = 1;
        player2Tank.sizeMultiplier = 1;
      };

      const drawMissile = () => {
        ctx.beginPath();
        ctx.arc(missileX, missileY, missileRadius, 0, Math.PI * 2);
        ctx.fillStyle = "blue";
        ctx.fill();
        ctx.closePath();
      };

      const drawGausing = () => {
        let centerX = currentPlayer === 1 ? tank1CenterX : tank2CenterX;
        let centerY =
          currentPlayer === 1
            ? tank1CenterY - cannonLength
            : tank2CenterY - cannonLength;
        ctx.beginPath();
        ctx.arc(centerX, centerY, gaugeBarRadius, Math.PI, gauge, false);
        ctx.stroke();
      };

      const tank2BodyImg = new Image();
      tank2BodyImg.src = "./picture/tank2BodyImage.png";
      const cannon2Image = new Image();
      cannon2Image.src = "./picture/cannon2Image.png";
      const drawTank = (
        tankX,
        tankCenterX,
        tankCenterY,
        cannonAngle,
        health,
        sizeMultiplier
      ) => {
        const scaledTankWidth = tankWidth * sizeMultiplier;
        const scaledTankHeight = tankHeight * sizeMultiplier;

        ctx.drawImage(
          tank2BodyImg,
          tankX,
          height - scaledTankHeight,
          scaledTankWidth,
          scaledTankHeight
        );

        // 포신 이미지 회전 및 그리기
        ctx.save();
        ctx.translate(tankCenterX, tankCenterY);
        ctx.rotate(-cannonAngle); // 캔버스의 y축이 아래쪽을 향하므로 -를 붙임
        ctx.drawImage(cannon2Image, 15, -25, 100, 70);
        ctx.restore();
      };

      const drawPlayerStatus = () => {
        ctx.font = "20px Arial";
        ctx.fillStyle = "black";
        ctx.fillText(`Player 1 HP: ${player1Health}`, 20, 30);
        ctx.fillText(`Player 2 HP: ${player2Health}`, width - 150, 30);

        drawPlayerItems(player1Tank, 20, 50);
        drawPlayerItems(player2Tank, width - 150, 50);
      };

      const drawPlayerItems = (tank, startX, startY) => {
        const skills = tank.skills.slice(0, 3); // 3개의 칸만 표시
        skills.forEach((skill, index) => {
          ctx.fillStyle = tank.skillAvailable[skill]
            ? "rgba(0, 0, 0, 1)"
            : "rgba(0, 0, 0, 0.5)";
          ctx.fillRect(startX + index * 40, startY, 30, 30);
          ctx.fillStyle = "white";
          ctx.fillText(
            skill[0].toUpperCase(),
            startX + index * 40 + 10,
            startY + 20
          );
        });
      };

      const keydownHandler = (event) => {
        const key = event.key;
        const currentTank = currentPlayer === 1 ? player1Tank : player2Tank;
        const opponentTank = currentPlayer === 1 ? player2Tank : player1Tank;

        if (currentPlayer === 1) {
          if (key === "a" || key === "A") {
            tank1LeftPressed = true;
          } else if (key === "d" || key === "D") {
            tank1RightPressed = true;
          } else if (key === "w" || (key === "W" && cannon1Angle <= Math.PI)) {
            cannon1Angle += cannonAngleDIF;
          } else if (key === "s" || (key === "S" && cannon1Angle >= 0)) {
            cannon1Angle -= cannonAngleDIF;
          }
        } else {
          if (key === "ArrowLeft") {
            tank2LeftPressed = true;
          } else if (key === "ArrowRight") {
            tank2RightPressed = true;
          } else if (key === "ArrowUp" && cannon2Angle <= Math.PI) {
            cannon2Angle += cannonAngleDIF;
          } else if (key === "ArrowDown" && cannon2Angle >= 0) {
            cannon2Angle -= cannonAngleDIF;
          }
        }

        if (key === " ") {
          if (!isFired) isCharging = true;
        } else if (["1", "2", "3", "8", "9", "0"].includes(key)) {
          useSkillByKey(currentTank, opponentTank, key);
        }
      };

      const keyupHandler = (event) => {
        const key = event.key;

        if (currentPlayer === 1) {
          if (key === "a" || key === "A") {
            tank1LeftPressed = false;
          } else if (key === "d" || key === "D") {
            tank1RightPressed = false;
          } else if (key === " " && isCharging) {
            isCharging = false;
            isFired = true;
            missilePower = gauge * 1.6;
            missileDx = missilePower * Math.cos(cannon1Angle);
            missileDy = missilePower * Math.sin(cannon1Angle);
            gauge = Math.PI; // 게이지 초기화
          }
        } else {
          if (key === "ArrowLeft") {
            tank2LeftPressed = false;
          } else if (key === "ArrowRight") {
            tank2RightPressed = false;
          } else if (key === " " && isCharging) {
            isCharging = false;
            isFired = true;
            missilePower = gauge * 1.6;
            missileDx = missilePower * Math.cos(cannon2Angle);
            missileDy = missilePower * Math.sin(cannon2Angle);
            gauge = Math.PI; // 게이지 초기화
          }
        }
      };

      const applySkill = (currentTank, opponentTank, skill) => {
        if (skill === "damage") {
          currentTank.damageMultiplier = 2;
        } else if (skill === "chance") {
          currentTank.doubleAttack = true;
          currentPlayerShots = 2;
        } else if (skill === "big") {
          currentTank.missileRadiusMultiplier = 2;
        } else if (skill === "area") {
          opponentTank.increasedRange = true;
          opponentTank.sizeMultiplier = 2; // 상대 탱크 크기 증가
        }
      };

      const useSkill = (tank, skill) => {
        tank.skillAvailable[skill] = false;
      };

      const useSkillByKey = (currentTank, opponentTank, key) => {
        const skillMap = {
          1: "damage",
          2: "chance",
          3: "big",
          8: "damage",
          9: "big",
          0: "area",
        };
        const skill = skillMap[key];
        if (
          currentTank.skills.includes(skill) &&
          currentTank.skillAvailable[skill]
        ) {
          applySkill(currentTank, opponentTank, skill);
          useSkill(currentTank, skill);
        }
      };

      document.addEventListener("keydown", keydownHandler, false);
      document.addEventListener("keyup", keyupHandler, false);
    </script>
  </body>
</html>
